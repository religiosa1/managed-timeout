{"version":3,"sources":["../src/AbortError.ts","../src/timeout.ts"],"sourcesContent":["/*\r\n * Technically, AbortError should be a descendant of DOMException, but\r\n * DOMException was only added in node v17.0.0, so we're using Error directly.\r\n */\r\nexport class AbortError extends Error {\r\n  readonly name = \"AbortError\" as const;\r\n  readonly code = 20 as const;\r\n\r\n  constructor(message = \"The operation was aborted.\") {\r\n    super(message);\r\n  }\r\n}","import { AbortError } from \"./AbortError\";\r\n\r\nexport const callbackError = \"Expeting to get a cb function as the first argument\" as const;\r\nexport const delayError = \"Delay argument should be a number >= 0\" as const;\r\nexport const repeatedStart = \"Timeout was already started\" as const;\r\n\r\nexport type TimeoutState = \"ready\" | \"pending\" | \"paused\" | \"resolved\" | \"cancelled\";\r\nexport class Timeout {\r\n  #state: TimeoutState = \"ready\";\r\n\r\n  #delay: number;\r\n  /** Time left for a timeout for the resume call (after it was paused) */\r\n  #timeLeft: number;\r\n  /** setTimeout identifier */\r\n  #to: any;\r\n  /** latest setTimeout call time as returned by Date.getTime() */\r\n  #startTime: number | undefined;\r\n  /** timeout callback */\r\n  #cb: ((to: Timeout)=>void) | null = null;\r\n  /** Promise cancellation callback */\r\n  #reject: ((reason: unknown) => void) | null = null;\r\n\r\n /** Timeout constructor, without scheduling a callback.\r\n   * Callback must be provided later with the start function.\r\n   * @param delay delay time in millieseconds\r\n   * @throws {Error} if cb isn't a function or a number or if delay isn't a number or less than zero.\r\n   */\r\n  constructor(delay: number);\r\n  /** Timeout constructor, schedueles timeout is callback is provided.\r\n   * @param cb callback to execute after delay time has passed, or delay time in millieseconds\r\n   * @param delay delay time in millieseconds\r\n   * @throws {Error} if cb isn't a function or a number or if delay isn't a number or less than zero.\r\n   */\r\n  constructor(cb: ((to: Timeout) => void), delay: number);\r\n  constructor(\r\n    cb_or_delay: ((to: Timeout) => void) | number,\r\n    delay?: number,\r\n  ) {\r\n    const d = (typeof cb_or_delay === \"number\") ? cb_or_delay : delay;\r\n    if (typeof d !== \"number\" || !Number.isInteger(d) || d < 0) {\r\n      throw new Error(delayError);\r\n    }\r\n    this.#delay = d;\r\n    this.#timeLeft = d;\r\n\r\n    if (typeof cb_or_delay !== \"number\") {\r\n      this.start(cb_or_delay);\r\n    }\r\n  }\r\n\r\n  get state(): TimeoutState {\r\n    return this.#state;\r\n  }\r\n\r\n  /** True if timeout is pending for execution (actively running or paused) */\r\n  get isPending(): boolean {\r\n    return this.#state === \"pending\" || this.#state === \"paused\";\r\n  }\r\n  /** True if timeout was started */\r\n  get isStarted(): boolean {\r\n    return this.#startTime != null;\r\n  }\r\n  /** True if timeout was canceled */\r\n  get isCanceled(): boolean {\r\n    return this.#state === \"cancelled\";\r\n  }\r\n  /** True if timeout was finished (normally or preemptively) */\r\n  get isFinished(): boolean {\r\n    return this.#state === \"resolved\";\r\n  }\r\n  /** True if timeout was finished preemptively */\r\n  get isFinishedPreemptively(): boolean {\r\n    return this.#state === \"resolved\" && this.#timeLeft > 0;\r\n  }\r\n  /** Time left (in ms) before the timeout execution */\r\n  get timeLeft(): number {\r\n    if (this.#state !== \"pending\") {\r\n      return this.#timeLeft;\r\n    }\r\n    return this.#delay - (new Date().getTime() - (this.#startTime ?? 0));\r\n  }\r\n  /** Number of milliseconds of delay time passed. */\r\n  get timePassed(): number {\r\n    return this.#delay - this.timeLeft;\r\n  }\r\n\r\n  /** Starts a timeout created without a callback.\r\n   * @returns a Promise, resolving after the delay time has passed.\r\n   */\r\n  start(): Promise<Timeout>;\r\n  /** Starts a timeout created without a callback.\r\n   * @param cb callback to be called after the delay time has passed.\r\n   * @returns true if callback was successfully started, false otherwise.\r\n   */\r\n  start(cb: (to: Timeout)=>void): boolean;\r\n  start(cb?: (to: Timeout) => void): Promise<Timeout> | boolean {\r\n    if (cb != null) {\r\n      if (typeof cb !== \"function\") { throw new Error(callbackError); }\r\n      if (this.isPending) {\r\n        return false;\r\n      }\r\n      this.#cb = cb;\r\n      this.#reject = null;\r\n      this.#run();\r\n      return true;\r\n    } else {\r\n      return new Promise((resolve, reject) => {\r\n        if (this.isPending) {\r\n          return reject(new Error(repeatedStart));\r\n        }\r\n        this.#cb = () => resolve(this);\r\n        this.#reject = (reason: unknown) => reject(reason);\r\n        this.#run();\r\n      });\r\n    }\r\n  }\r\n\r\n  /** Cancels the timeout completely.\r\n   * @returns true if the timeout was stopped, false if it wasn't pending to begin with\r\n   */\r\n  cancel(): boolean {\r\n    if (this.#state !== \"pending\" && this.#state !== \"paused\") { return false; }\r\n    this.#halt();\r\n    this.#state = \"cancelled\";\r\n    this.#reject?.(new AbortError());\r\n    return true;\r\n  }\r\n\r\n  /** Execute pending timeout's CB preemptively, without waiting for the delay time and finishing it.\r\n   * Repeated invokations won't run the cb, and false would be returned instead.\r\n   * @returns {boolean} true if the timeout was finished, false if it was already finished or canceled before\r\n   */\r\n  execute(): boolean {\r\n    if (this.#state === \"resolved\" || this.state === \"cancelled\") { return false; }\r\n    this.#halt();\r\n    this.#state = \"resolved\";\r\n    // we need to check cb here, as one run execute right after the constructor call, without start\r\n    this.#cb?.(this);\r\n    return true;\r\n  }\r\n\r\n  /** Pauses the timeout.\r\n   * If it was already paused do nothing.\r\n   * @returns {boolean} true if the timeout was paused, false otherwise.\r\n   */\r\n  pause(): boolean {\r\n    if (this.#state !== \"pending\") { return false; }\r\n    this.#halt();\r\n    this.#state = \"paused\";\r\n    return true;\r\n  }\r\n\r\n  /** Resumes the paused timeout.\r\n   * If it wasn't paused do nothing.\r\n   * @returns {boolean} true if the timeout was resumed, false otherwise.\r\n   */\r\n  resume(): boolean {\r\n    if (this.#state !== \"paused\") { return false; }\r\n    this.#run();\r\n    return true;\r\n  }\r\n\r\n  /** Timeout pause/resume status. */\r\n  get paused(): boolean {\r\n    return this.#state === \"paused\";\r\n  }\r\n  set paused(val: boolean) {\r\n    if (val) {\r\n      this.pause();\r\n    } else {\r\n      this.resume();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset the timeout's delay with the previous delay value or a new one.\r\n   * The timeout will be unpaused and running if it's in the paused state.\r\n   * If the timeout was finished or canceled do nothing, return false.\r\n   * If timeout wasn't started just changes the delay time.\r\n   * @param delay time to which reset the timeout (default the same as before)\r\n   * @throws {Error} if delay was supplied and it isn't a number >= 0\r\n   * @return status if timeout was reset or not.\r\n   */\r\n  reset(delay?: number): boolean {\r\n    if ( delay == null) { delay = this.#delay; }\r\n    if (typeof delay !== \"number\" || delay < 0) {\r\n      throw new Error(delayError);\r\n    }\r\n    if (this.isStarted) {\r\n      if (!this.isPending) { return false; }\r\n      this.#halt();\r\n      this.#delay = delay;\r\n      this.#timeLeft = delay;\r\n      this.#run();\r\n    } else {\r\n      this.#delay = delay;\r\n      this.#timeLeft = delay;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Current set total delay (from the constructor or consecutive calls to reset) */\r\n  get delay(): number {\r\n    return this.#delay;\r\n  }\r\n\r\n  #run() {\r\n    this.#startTime = new Date().getTime();\r\n    this.#state = \"pending\";\r\n    this.#to = setTimeout(()=>{\r\n      this.#to = null;\r\n      this.#state = \"resolved\";\r\n      this.#timeLeft = 0;\r\n      this.#cb?.(this);\r\n    }, this.#timeLeft);\r\n  }\r\n  #halt() {\r\n    if (this.#to) {\r\n      clearTimeout(this.#to);\r\n      this.#to = null;\r\n    }\r\n    this.#timeLeft = this.timeLeft;\r\n  }\r\n}\r\nexport default Timeout;"],"mappings":"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","names":["AbortError","message","callbackError","delayError","repeatedStart","_state","_delay","_timeLeft","_to","_startTime","_cb","_reject","_run","run_fn","_halt","halt_fn","Timeout","cb_or_delay","delay","__privateAdd","d","__privateSet","__privateGet","_a","cb","__privateMethod","resolve","reject","reason","AbortError","val","timeout_default"]}