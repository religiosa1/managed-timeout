{"version":3,"sources":["../src/timeout.ts"],"sourcesContent":["export const callbackError = \"Expeting to get a cb function as the first argument\";\r\nexport const delayError = \"Delay argument should be a number >= 0\";\r\nexport const repeatedStart = \"Timeout was already started\";\r\n\r\nexport type TimeoutState = \"ready\" | \"pending\" | \"paused\" | \"resolved\" | \"cancelled\";\r\nexport class Timeout {\r\n  #state: TimeoutState = \"ready\";\r\n\r\n  #delay: number;\r\n  /** Time left for a timeout for the resume call (after it was paused) */\r\n  #timeLeft: number;\r\n  /** setTimeout identifier */\r\n  #to: any;\r\n  /** latest setTimeout call time as returned by Date.getTime() */\r\n  #startTime: number;\r\n  /** timeout callback */\r\n  #cb: (to: Timeout)=>void;\r\n\r\n /** Timeout constructor, without scheduling a callback.\r\n   * Callback must be provided later with the start function.\r\n   * @param delay delay time in millieseconds\r\n   * @throws {Error} if cb isn't a function or a number or if delay isn't a number or less than zero.\r\n   */\r\n  constructor(delay: number);\r\n  /** Timeout constructor, schedueles timeout is callback is provided.\r\n   * @param cb callback to execute after delay time has passed, or delay time in millieseconds\r\n   * @param delay delay time in millieseconds\r\n   * @throws {Error} if cb isn't a function or a number or if delay isn't a number or less than zero.\r\n   */\r\n  constructor(cb: ((to: Timeout) => void), delay: number);\r\n  constructor(\r\n    cb_or_delay: ((to: Timeout) => void) | number,\r\n    delay?: number,\r\n  ) {\r\n    const d = (typeof cb_or_delay === \"number\") ? cb_or_delay : delay;\r\n    if (!Number.isInteger(d) || d < 0) {\r\n      throw new Error(delayError);\r\n    }\r\n    this.#delay = d;\r\n    this.#timeLeft = d;\r\n\r\n    if (typeof cb_or_delay !== \"number\") {\r\n      this.start(cb_or_delay);\r\n    }\r\n  }\r\n\r\n  get state(): TimeoutState {\r\n    return this.#state;\r\n  }\r\n\r\n  /** True if timeout is pending for execution (actively running or paused) */\r\n  get isPending(): boolean {\r\n    return this.#state === \"pending\" || this.#state === \"paused\";\r\n  }\r\n  /** True if timeout was started */\r\n  get isStarted(): boolean {\r\n    return this.#startTime != null;\r\n  }\r\n  /** True if timeout was canceled */\r\n  get isCanceled(): boolean {\r\n    return this.#state === \"cancelled\";\r\n  }\r\n  /** True if timeout was finished (normally or preemptively) */\r\n  get isFinished(): boolean {\r\n    return this.#state === \"resolved\";\r\n  }\r\n  /** True if timeout was finished preemptively */\r\n  get isFinishedPreemptively(): boolean {\r\n    return this.#state === \"resolved\" && this.#timeLeft > 0;\r\n  }\r\n  /** Time left (in ms) before the timeout execution */\r\n  get timeLeft(): number {\r\n    if (this.#state !== \"pending\") {\r\n      return this.#timeLeft;\r\n    }\r\n    return this.#delay - (new Date().getTime() - this.#startTime);\r\n  }\r\n  /** Number of milliseconds of delay time passed. */\r\n  get timePassed(): number {\r\n    return this.#delay - this.timeLeft;\r\n  }\r\n\r\n  /** Starts a timeout created without a callback.\r\n   * @returns a Promise, resolving after the delay time has passed.\r\n   */\r\n  start(): Promise<Timeout>;\r\n  /** Starts a timeout created without a callback.\r\n   * @param cb callback to be called after the delay time has passed.\r\n   * @returns true if callback was successfully started, false otherwise.\r\n   */\r\n  start(cb: (to: Timeout)=>void): boolean;\r\n  start(cb?: (to: Timeout) => void): Promise<Timeout> | boolean {\r\n    if (cb != null) {\r\n      if (typeof cb !== \"function\") { throw new Error(callbackError); }\r\n      if (this.isPending) {\r\n        return false;\r\n      }\r\n      this.#cb = cb;\r\n      this.#run();\r\n      return true;\r\n    } else {\r\n      return new Promise((resolve, reject) => {\r\n        if (this.isPending) {\r\n          return reject(new Error(repeatedStart));\r\n        }\r\n        this.#cb = () => resolve(this);\r\n        this.#run();\r\n      });\r\n    }\r\n  }\r\n\r\n  /** Cancels the timeout completely.\r\n   * @returns true if the timeout was stopped, false if it wasn't pending to begin with\r\n   */\r\n  cancel(): boolean {\r\n    if (this.#state !== \"pending\" && this.#state !== \"paused\") { return false; }\r\n    this.#halt();\r\n    this.#state = \"cancelled\";\r\n    return true;\r\n  }\r\n\r\n  /** Execute pending timeout's CB preemptively, without waiting for the delay time and finishing it.\r\n   * Repeated invokations won't run the cb, and false would be returned instead.\r\n   * @returns {boolean} true if the timeout was finished, false if it was already finished or canceled before\r\n   */\r\n  execute(): boolean {\r\n    if (this.#state === \"resolved\" && this.state === \"cancelled\") { return false; }\r\n    this.#halt();\r\n    this.#state = \"resolved\";\r\n    // we need to check cb here, as one run execute right after the constructor call, without start\r\n    this.#cb?.(this);\r\n    return true;\r\n  }\r\n\r\n  /** Pauses the timeout.\r\n   * If it was already paused do nothing.\r\n   * @returns {boolean} true if the timeout was paused, false otherwise.\r\n   */\r\n  pause(): boolean {\r\n    if (this.#state !== \"pending\") { return false; }\r\n    this.#halt();\r\n    this.#state = \"paused\";\r\n    return true;\r\n  }\r\n\r\n  /** Resumes the paused timeout.\r\n   * If it wasn't paused do nothing.\r\n   * @returns {boolean} true if the timeout was resumed, false otherwise.\r\n   */\r\n  resume(): boolean {\r\n    if (this.#state !== \"paused\") { return false; }\r\n    this.#run();\r\n    return true;\r\n  }\r\n\r\n  /** Timeout pause/resume status. */\r\n  get paused(): boolean {\r\n    return this.#state === \"paused\";\r\n  }\r\n  set paused(val: boolean) {\r\n    if (val) {\r\n      this.pause();\r\n    } else {\r\n      this.resume();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset the timeout's delay with the previous delay value or a new one.\r\n   * The timeout will be unpaused and running if it's in the paused state.\r\n   * If the timeout was finished or canceled do nothing, return false.\r\n   * If timeout wasn't started just changes the delay time.\r\n   * @param delay time to which reset the timeout (default the same as before)\r\n   * @throws {Error} if delay was supplied and it isn't a number >= 0\r\n   * @return status if timeout was reset or not.\r\n   */\r\n  reset(delay?: number): boolean {\r\n    if ( delay == null) { delay = this.#delay; }\r\n    if (typeof delay !== \"number\" || delay < 0) {\r\n      throw new Error(delayError);\r\n    }\r\n    if (this.isStarted) {\r\n      if (!this.isPending) { return false; }\r\n      this.#halt();\r\n      this.#delay = delay;\r\n      this.#timeLeft = delay;\r\n      this.#run();\r\n    } else {\r\n      this.#delay = delay;\r\n      this.#timeLeft = delay;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Current set total delay (from the constructor or consecutive calls to reset) */\r\n  get delay(): number {\r\n    return this.#delay;\r\n  }\r\n\r\n  #run() {\r\n    this.#startTime = new Date().getTime();\r\n    this.#state = \"pending\";\r\n    this.#to = setTimeout(()=>{\r\n      this.#to = null;\r\n      this.#state = \"resolved\";\r\n      this.#timeLeft = 0;\r\n      this.#cb(this);\r\n    }, this.#timeLeft);\r\n  }\r\n  #halt() {\r\n    if (this.#to) {\r\n      clearTimeout(this.#to);\r\n      this.#to = null;\r\n    }\r\n    this.#timeLeft = this.timeLeft;\r\n  }\r\n}\r\nexport default Timeout;"],"mappings":"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","names":["callbackError","delayError","repeatedStart","_state","_delay","_timeLeft","_to","_startTime","_cb","_run","run_fn","_halt","halt_fn","Timeout","cb_or_delay","delay","__privateAdd","d","__privateSet","__privateGet","cb","__privateMethod","resolve","reject","_a","val","timeout_default"]}